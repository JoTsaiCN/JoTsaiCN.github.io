<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用Appium测试iOS应用(Python)]]></title>
    <url>%2F2017%2F08%2F26%2F%E4%BD%BF%E7%94%A8Appium%E6%B5%8B%E8%AF%95iOS%E5%BA%94%E7%94%A8-Python%2F</url>
    <content type="text"><![CDATA[环境要求 macOS 12 iOS 10 Appium 的 iOS 环境搭建完毕 安装 Appium 的 python 客户端库 安装 python 下载安装包安装 下载地址 通过 brew 安装 1brew install python3 安装 Appium 的 python 客户端库 使用 pip 安装 1pip3 install Appium-Python-Client 通过编译源码安装 123git clone git@github.com:appium/python-client.gitcd python-clientpython3 setup.py install 启动 Appium Server Appium 桌面版本：运行 Appium desktop，点击 Start Server 按钮 Appium 命令行版本：在终端中执行以下命令 1appium 启动 Session指定测试应用 有三种方式指定测试应用，此时默认上下文为 native 类型 desired_capabilities 指定 app 关键字为 .ipa 文件或 .app 文件的本地路径 desired_capabilities 指定 app 关键字为 .ipa 文件或 .app 文件的 HTTP 地址 desired_capabilities 指定 bundleId 关键字为应用的 Bundle Identifier，这种方式要求应用在创建 session 前已安装在设备上 使用以下方式指定测试 web 时要启动的浏览器，此时默认上下文为 webview 类型 desired_capabilities 指定 browserName 关键字为浏览器名称，指定 startIWDP 关键字为 True 重置策略 desired_capabilities 指定 fullReset 关键字或 noReset 关键字的值为 true 来设置重置策略 fullReset 和 noReset 默认为 false，此时采用 默认重置策略 默认 fullReset noReset iOS 真机测试前卸载已安装的 app。不重启模拟器。 真机测试前卸载已安装的 app。模拟器测试前会重启模拟器。 真机测试前不卸载已安装的 app。不重启模拟器。 12345678910# fullResetdesired_capabilities=&#123; '……省略……': '……省略……', 'fullReset': True&#125;# noResetdesired_capabilities=&#123; '……省略……': '……省略……', 'noReset': True&#125; 创建和结束 Session 创建 session webdriver.Remote(command_executor, desired_capabilities) 结束 session WebDriver.quit() 123456789101112from appium import webdriverdriver = webdriver.Remote( command_executor='http://0.0.0.0:4723/wd/hub', desired_capabilities=&#123; 'platformName': 'iOS', 'platformVersion': '10.1.1', 'deviceName': 'iPhone6', 'udid': '设备udid', 'app': 'app路径' &#125;)driver.quit() 参数 command_executor: 字符串类型，appium server 监听的地址 desired_capabilities: 字典类型，启动 session 的参数 说明 webdriver.Remote 返回一个 appium.webdriver.webdriver.WebDriver 对象 WebDriver.quit 返回 None 如果无法创建或结束 session，会抛出 WebDriverException 异常 设备操作重启 sessionWebDriver.reset() 1driver.reset() 【说明】 返回 WebDriver 对象 app 操作 卸载 WebDriver.remove_app(app_id) 安装 WebDriver.install_app(app_path) 启动 WebDriver.launch_app() 123driver.remove_app('com.GuangZhouXuanWu.iphoneEtion')driver.install_app('app_path')driver.launch_app() 【参数】 app_id: app 的 bundleId app_path: app 安装包文件路径 【说明】 返回 WebDriver 对象 launch_app 启动的是 app 关键字指定的应用，所以不需要参数 上下文操作 获取上下文 WebDriver.contexts WebDriver.context WebDriver.current_context 123driver_contexts = driver.contextsdriver_context = driver.contextdriver_current_context = driver.current_context 【说明】 WebDriver.context 返回一个字符串，为当前上下文名称 WebDriver.contexts 返回一个包含当前会话所有上下文名称的 list WebDriver.current_context 等价于 WebDriver.context 切换上下文 WebDriver.switch_to.context(context_name) 12345driver.switch_to.context('WEBVIEW_1')# 切换到 webview 类型的上下文后，使用 web 自动化 APIdriver.get('http://www.baidu.com')web_element = driver.find_element(MobileBy.CSS_SELECTOR, 'button.se-bn')driver.switch_to.context('NATIVE_APP') 【说明】 返回 None 获取 UI 布局WebDriver.page_source 1driver_page_source = driver.page_source 【说明】 当前上下文为 native 时，返回一个 xml 格式的字符串 当前上下文为 webview 时，返回一个 html 格式的字符串 获取分辨率WebDriver.get_window_size() 1driver_size = driver.get_window_size() 【说明】 返回一个字典 返回逻辑分辨率 关于 iPhone 的分辨率可参考该网址 ultimate-guide-to-iphone-resolutions 屏幕截图 返回二进制数据 WebDriver.get_screenshot_as_png() 返回一个字符串 WebDriver.get_screenshot_as_base64() 保存到文件中 WebDriver.get_screenshot_as_file(filename) 保存到文件中 WebDriver.save_screenshot(filename) 12345678910# bytesimage_bytes = driver.get_screenshot_as_png()# base64image_base64 = driver.get_screenshot_as_base64()html_str = '&lt;html&gt;&lt;body&gt;&lt;img src="data:image/png;base64, %s"/&gt;&lt;/body&gt;&lt;/html&gt;' % image_base64html_file = open('./image.html', 'w')html_file.write(html_str)html_file.close()# filedriver.get_screenshot_as_file('./save_image.png') 【参数】 filename: 字符串类型，指定保存路径 【说明】 返回的截图分辨率大小为渲染分辨率 get_screenshot_as_png 返回 bytes 类型 get_screenshot_as_base64 返回字符串类型，适用于将图片嵌入到 HTML 中 get_screenshot_as_file 成功时返回 True，失败返回 False save_screenshot 与 get_screenshot_as_file 等价 弹窗操作 接受弹窗 WebDriver.switch_to.alert.accept() 拒绝弹窗 WebDriver.switch_to.alert.dismiss() 获取文本 WebDriver.switch_to.alert.text 123driver.switch_to.alert.accept()driver.switch_to.alert.dismiss()alert_text = WebDriver.switch_to.alert.text 【说明】 返回 None 屏幕操作 点击 WebDriver.tap(positions, duration) 123driver.tap([(200, 300)], 200)# 暂时不支持多点触碰driver.tap([(50, 50), (150, 150)], 200) 【参数】 positions: 类型为 list，列出所有点击坐标，点击坐标格式为 (x, y) duration: 点击的时长，单位为 ms，默认为 None 【说明】 返回 WebDriver 对象 最多可以有 5 个点击坐标，对应最多 5 个手指的多点触碰 滚动 WebDriver.scroll(origin_el, destination_el) 12destination_el = driver.find_element(MobileBy.ACCESSIBILITY_ID, '列表-cell-农夫山泉')driver.scroll(None, destination_el) 【参数】 origin_el: WebElement 对象，表示滚动的起始位置 destination_el: WebElement 对象，表示滚动的结束位置 【说明】 返回 WebDriver 对象 scroll 方法为滚动界面直到 destination_el 元素显示在屏幕上，因此 origin_el 参数没有意义，传 None 即可 划动 WebDriver.swipe(start_x, start_y, end_x, end_y, duration) 1driver.swipe(200, 400, 0, -100, 100) 【参数】 start_x: 起始位置的 x 轴坐标 start_y: 起始位置的 y 轴坐标 end_x: x 轴偏移量 end_y: y 轴偏移量 duration: 点击起始位置和开始划动的间隔时间，默认为 None 【说明】 返回 WebDriver 对象 执行指令WebDriver.execute_script(script, *args) 12destination_el = driver.find_element(MobileBy.ACCESSIBILITY_ID, '列表-cell-农夫山泉')driver.execute_script('mobile: scroll', &#123;'element': destination_el, 'toVisible': True&#125;) 【参数】 script: 执行的指令 args: 指令的参数 【说明】 在 native 类型的上下文中使用 mobile: 指令 指定要执行的操作，详细说明查看 XCTest 手势操作 在 webview 类型的上下文中与 web 自动化的用法一样 后台运行WebDriver.background_app(seconds) 1driver.background_app(1) 【参数】 seconds: 后台运行的时长，单位为秒 【说明】 将 app 后台运行指定时长后，再将 app 前台运行 返回 WebDriver 对象 获取设备时间WebDriver.device_time 1234import datetimedevice_time_str = driver.device_timedevice_time = datetime.datetime.strptime(device_time_str[:-6], '%a %b %d %Y %H:%M:%S %Z%z')device_time = device_time - datetime.timedelta(hour=14) 【说明】 返回字符串 通过执行 idevicedate 命令来获取设备时间 这里存在一个问题，idevicedate 返回的时间为 Fri Aug 4 15:29:15 CST 2017，CST 可以代表 4 个时区，在这里表示 中国标准时间，但 appium 将 CST 当成 美国中部标准时间，因此返回的时间比实际快 14 个小时 获取本地化字符串WebDriver.app_strings(language, string_file) 1device_app_strings = driver.app_strings(language='zh-Hans') 【参数】 language: 指定要获取哪一种语言的本地化文件 string_file: 指定本地化文件的文件名 【说明】 返回一个字典 需要在 desired_capabilities 中指定 app 关键字 实际上是通过解压本地的 app 包来获取 [language].lproj 文件夹（比如 zh-Hans.lproj）下的 [string_file] 文件（默认为 Localizable.strings），所以调用该方法的时候需要注意 iOS 上安装的包是否与 app 关键字指定的安装包一致 查找元素查找单个元素 WebDriver.find_element(by, value) 12from appium.webdriver.common.mobileby import MobileBy element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录') 查找多个元素 WebDriver.find_elements(by, value) 12from appium.webdriver.common.mobileby import MobileBy elements = driver.find_elements(MobileBy.ACCESSIBILITY_ID, '登录') 参数 by: 定位策略 value: 定位策略的参数 说明 find_element 返回一个 WebElement 对象，对应找到的第一个元素，find_elements 返回一个 list ，包含找到的所有元素的 如果找不到元素，find_element 会抛出 NoSuchElementException 异常，find_elements 会返回一个空列表 WebDriver.find_element(By.XXX, value) 等价于 WebDriver.find_element_by_xxx(value) 1element = driver.find_element_by_accessibility_id('登录') WebDriver.find_elements(By.XXX, value) 等价于 WebDriver.find_elements_by_xxx(value) 1elements = driver.find_elements_by_accessibility_id('登录') 定位策略Appium 支持部分 WebDriver 定位策略 class name按 UI 元素类型查找 1element = driver.find_element(MobileBy.CLASS_NAME, 'XCUIElementTypeButton') xpath 1element = driver.find_element(MobileBy.XPATH, '//XCUIElementTypeApplication[@name="玄讯快销100"]/XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeTable/XCUIElementTypeCell[4]/XCUIElementTypeButton[1]') id在 iOS 设备上与 accessibility id 等价 1element = driver.find_element(MobileBy.ID, '登录') name在 iOS 设备上与 accessibility id 等价 1element = driver.find_element(MobileBy.NAME, '登录') Appium还添加了对 Mobile JSON 连接协议 部分定位策略的支持 accessibility id 1element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录') ios predicate限 iOS，通过使用多个属性匹配条件来定位元素，常见属性有 type, value, name, label, enabled, visible 比较运算符==, &gt;=, &lt;= , >, &lt;, !=, BETWEEN {n, m}, IN {s1, s2, s3} 123element = driver.find_element(MobileBy.IOS_PREDICATE, 'type == "XCUIElementTypeButton"')element = driver.find_element(MobileBy.IOS_PREDICATE, 'value BETWEEN &#123;10, 20&#125;')element = driver.find_element(MobileBy.IOS_PREDICATE, 'name IN &#123;"登录", "用户名", "密码"&#125;') 逻辑运算AND, OR, NOT 1element = driver.find_element(MobileBy.IOS_PREDICATE, 'visible == true AND label == "登录"') 字符串比较BEGINSWITH, CONTAINS, ENDSWITH, LIKE, MATCHES （MATCHES 根据 ICUv3 的正则表达式进行匹配） 1element = driver.find_element(MobileBy.IOS_PREDICATE, 'name CONTAINS "Login"') ios class chain限 iOS 9.3 及以上 1element = driver.find_element('-ios class chain', 'XCUIElementTypeWindow[1]/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeOther/XCUIElementTypeTable/XCUIElementTypeCell[4]/XCUIElementTypeButton[1]') ios uiautomation限 iOS 9.3 及以下 android uiautomator限 Android 如何选择定位策略 尽量使用 accessibility id 和 ios predicate 其次使用 ios class chain 和 ios uiautomation ，因为这两个定位策略有操作系统版本限制 尽量不要使用 xpath，尽管 xpath 不受操作系统版本限制，但是因为 iOS 并没有原生支持 xpath，是由 Appium 服务器解析整个 UI 布局来查找的，速度非常慢，比如上面的 xpath 示例耗时 4s 多，而类似的 ios class chain 示例耗时为 1.5s 如何确定设备支持的定位策略 每次向 appium 服务器发送查找元素的请求时，服务器会有如下的日志输出，列出设备支持的所有定位策略 1[BaseDriver] Valid locator strategies for this request: xpath, id, name, class name, -ios predicate string, -ios class chain, accessibility id 等待策略Appium 支持 WebDriver 的 2 种等待策略，在指定的等待时间中不断查找元素，直到 找到元素 或者 超时 隐式等待WebDriver.implicitly_wait(time_to_wait) 123driver.implicitly_wait(10)element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录')driver.implicitly_wait(0) 【参数】 time_to_wait: 为 0 时表示关闭隐式等待，大于 0 时表示开启隐式等待且等待时间设为 time_to_wait，单位为秒；创建session 时默认为关闭隐式等待 【说明】 隐式等待一旦开启，在关闭隐式等待或者结束 session 之前，调用元素查找方法的等待策略都为隐式等待 如果在 time_to_wait 时间内找不到元素，抛出 NoSuchElementException 异常 12345678driver.implicitly_wait(10)# 找不到元素element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '找不到的元素')# 抛出的异常"""……省略……selenium.common.exceptions.NoSuchElementException: Message: An element could not be located on the page using the given search parameters.""" 显式等待 反复调用 method 方法，直到该方法返回值为 True WebDriverWait(driver, timeout, poll_frequency, ignored_exceptions).until(method, message) 123from selenium.webdriver.support.wait import WebDriverWait# 返回找到的元素element = WebDriverWait(driver, 5, 1).until(lambda x: x.find_element(MobileBy.ACCESSIBILITY_ID, '登录')) 反复调用 method 方法，直到该方法返回值为 False WebDriverWait(driver, timeout, poll_frequency, ignored_exceptions).until_not(method, message) 123from selenium.webdriver.support.wait import WebDriverWait# 返回 Truenot_found = WebDriverWait(driver, 5, 1).until_not(lambda x: x.find_element(MobileBy.ACCESSIBILITY_ID, '找不到的元素')) 【参数】 driver: WebDriver 对象，作为 method 方法的第一个参数 timeout: 超时时间 poll_frequency: 执行间隔，默认为 0.5 秒 ignored_exceptions: 执行方法时忽略的异常，可以有多个，默认为 NoSuchElementException method: 执行的方法 message: 抛出 TimeoutException 时附带的信息，默认为空字符串 【说明】 在 timeout 时间内，每隔 poll_frequency 秒调用一次 method 方法，直到超时或者 method 方法的返回值为 True / False 返回值为 method 方法的返回值 在调用 method 方法的时候，如果抛出的异常在 ignored_exceptions 里则忽略并继续，否则抛出异常 超时会抛出 TimeoutException 异常，无法用 ignored_exceptions 忽略 12345678from selenium.webdriver.support.wait import WebDriverWait# 找不到元素element = WebDriverWait(driver, 5).until(lambda x: x.find_element(MobileBy.ACCESSIBILITY_ID, '找不到的元素'))# 抛出的异常"""……省略……selenium.common.exceptions.TimeoutException: Message: """ 元素操作获取属性 获取指定属性 WebElement.get_attribute(name) 12element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录')element_label = element.get_attribute('label') 【参数】 name: 属性名称，字符串 【说明】 返回指定属性的值，通常为字符串类型。常用的属性有 name、value、type、label 属性不存在时抛出 WebDriverException 异常 获取元素的坐标和大小 WebElement.location WebElement.size WebElement.rect 1234element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录')element_location = element.location # &#123;'x': 15, 'y': 190&#125;element_size = element.size # &#123;'width': 17, 'height': 17&#125;element_rect = element.rect # &#123;'width': 17, 'height': 17, 'x': 15, 'y': 190&#125; 【说明】 返回值为字典类型 获取元素的类型和文本值 WebElement.tag_name 和 WebElement.text 123element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录')element_tag = element.tag_name # XCUIElementTypeButtonelement_text = element.text # 登录 【说明】 返回值为文本 获取显示状态 WebElement.is_displayed() 12element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录')element_is_displayed = element.is_displayed() 【说明】 返回值为 bool 类型 点击 WebElement.click() 12element = driver.find_element(MobileBy.ACCESSIBILITY_ID, '登录')element.click() 【说明】 返回 None 赋值 WebElement.send_keys(value) 12element = driver.find_element(MobileBy.ACCESSIBILITY_ID, 'LoginUserName')element.send_keys('758002') 【参数】 value: 要赋给元素的值 【说明】 支持 TextField 和 PickerWheel 类型的 UI 元素 赋值成功返回 None TextField 元素调用 send_keys 方法时： 在原有的值后面添加新的值 要求点击元素时能呼出键盘，否则会抛出 WebDriverException 异常 issue: 如果 WebDriverAgentRunner 模拟键入的速度太快可能导致 session 出现异常，解决方法是设置 desired_capabilities， 将默认为 60 的 maxTypingFrequency 改小为 10 至 20 清空 WebElement.clear() 123element = driver.find_element(MobileBy.ACCESSIBILITY_ID, 'LoginUserName')element.send_keys('123456')element.clear() 【说明】 支持 TextView 类型 要求点击元素时能呼出键盘，否则会抛出 WebDriverException 异常 查找元素 WebElement.find_element(by, value) WebElement.find_elements(by, value) 12element = driver.find_element(MobileBy.ACCESSIBILITY_ID, 'TableList')sub_element = element.find_element(MobileBy.ACCESSIBILITY_ID, '表单-今日拜访') 【说明】 参数和返回值与 WebDriver 同名 API 相同 以 UI 元素为根节点进行查找 XCTest 手势操作XCTest 提供了非常丰富的手势操作，这些操作都是 iOS 平台独有的。从 1.6.4-beta 版本开始的 Appium 支持 XCTest 手势操作。需要特别注意的是目前 XCTest 和 WDA 正在不断优化改变的阶段，这意味着所有 mobile: * 的命令可能会在没任何通知的情况下就被调整更改。 mobile: swipe这个手势是在指定的屏幕上的控件或App的控件上执行“滑动”操作，一般是针对整个屏幕。这个方法不支持通过坐标来操作，并且仅仅是简单的模拟单个手指滑动。这个方法对于诸如相册分页、切换视图等情况可能会发挥比较大的作用。更复杂的场景可能需要用到mobile:dragFromToForDuration，这个方法支持传坐标（coordinates ）和滑动持续时间（duration）。 【支持参数】 direction: ‘up’, ‘down’, ‘left’ or ‘right’. 这4个参数是固定的。 element: 需要滑动的控件ID（作为十六进制哈希字符串）。如果没有提供该参数的话，则会使用App的控件作为替代。 【用法示例】 1driver.execute_script('mobile: swipe', &#123;'direction': 'down', 'element': element&#125;); mobile: scroll滚动元素或整个屏幕。支持不同的滚动策略。该方法提供了4个可选择滑动策略：按照顺序有“name”，“direction”，“predicateString”或“toVisible”。所有的滑动策略都是排他性的，一次滑动只能选择一个策略。你可以使用mobile:scroll来对表格中或者集合视图中的某个已知控件进行精确的滚动操作。然而目前有一个已知的局限问题：如果需要在父容器上执行太多的滚动手势来达到必要的子元素（其中几十个），则方法调用可能会失败。 【支持参数】 element: 需要滚动的控件ID（作为十六进制哈希字符串）。如果没有提供该参数的话，则会使用App的控件作为替代。 name: 需要执行滚动的子控件的accessibility id。 将predicateString参数设置为“name == accessibilityId”可以实现相同的结果。如果element不是容器，则不起作用。 direction: ‘up’, ‘down’, ‘left’ or ‘right’. 该参数与swipe中的比，差别在于scroll会尝试将当前界面完全移动到下一页。（page一词表示单个设备屏幕中的所有内容） predicateString: 需要被执行滚动操作的子控件的NSPredicate定位器。如果控件不是容器，则不起作用。 toVisible: 布尔类型的参数。如果设置为true，则表示要求滚动到父控件中的第一个可见到的子控件。如果element未设置，则不生效。 【用法示例】 1driver.execute_script('mobile: scroll', &#123;'direction': 'down'&#125;); mobile: pinch在给定的控件或应用程序控件上执行捏合手势。 【支持参数】 element: 需要捏合的控件ID（作为十六进制哈希字符串）。如果没有提供该参数的话，则会使用App的控件作为替代。 scale: 浮动型夹点尺度。使用0和1之间的比例来“捏紧”或缩小，大于1的比例“撑开”或放大。强制参数 velocity: 每秒缩放速度（浮点值）。强制参数 【用法示例】 1driver.execute_script('mobile: pinch', &#123;'scale': 0.5, 'velocity': 1.1, 'element': element&#125;) mobile: doubleTap在指定控件上或屏幕上执行双击手势。 【支持参数】 element: 需要双击的控件ID（作为十六进制哈希字符串）。如果没有提供该参数的话，则会使用App的控件作为替代。 x: 屏幕x轴坐标点，浮点型. 仅当element未设置时才是强制参数 y: 屏幕y轴坐标点，浮点型. 仅当element未设置时才是强制参数 【用法示例】 1driver.execute_script('mobile: doubleTap', &#123;'element': element&#125;); mobile: touchAndHold在指定控件上或屏幕上长按的手势操作。 【支持参数】 element: 需要长按的控件ID（作为十六进制哈希字符串）。如果没有提供该参数的话，则会使用App的控件作为替代。 duration: 长按的持续时间（秒），浮点型。强制性参数 x: 屏幕x轴坐标点，浮点型. 仅当element未设置时才是强制参数 y: 屏幕y轴坐标点，浮点型. 仅当element未设置时才是强制参数 【用法示例】 1driver.execute_script('mobile: touchAndHold', &#123;'duration': 2.0, 'element': element&#125;); mobile: twoFingerTap在给定元素或应用程序元素上执行两个手指点击手势。 【支持参数】 element: 需要两只手指操作的控件ID（作为十六进制哈希字符串）。如果没有提供该参数的话，则会使用App的控件作为替代。 【用法示例】 1driver.execute_script('mobile: twoFingerTap', &#123;'element': element&#125;); mobile: tap在指定控件或屏幕上的坐标执行点击手势。 【支持参数】 element: 控件ID（作为十六进制哈希字符串）。 如果设置 了element参数，则x、y代表的是以当前element为边界的xy轴。若未设置，则x,y代表的是以手机屏幕为边界。 x: x轴坐标，类型为float。强制参数 y: y轴坐标，类型为float。强制参数 【用法示例】 1driver.execute_script('mobile: tap', &#123;'x': 100, 'y': 50, 'element': element&#125;); mobile: dragFromToForDuration通过坐标点执行拖放手势。可以在控件上执行，也可以在屏幕上执行。 【支持参数】 element: 控件ID（作为十六进制哈希字符串）。 如果设置 了element参数，则x、y代表的是以当前element为边界的xy轴。若未设置，则x,y代表的是以手机屏幕为边界。 duration: 浮点数范围[0.5,60]。表示开始拖动点之前的点击手势需要多长时间才能开始拖动。强制参数 fromX: 起始拖动点的x坐标（类型float）。强制参数 fromY: 起始拖动点的y坐标（类型float）。强制参数 toX: 结束拖曳点的x坐标（float类型）。强制参数 toY: 结束拖动点的y坐标（类型float）。强制参数 【用法示例】 1driver.execute_script('mobile: dragFromToForDuration', &#123;'duration': 1, 'fromX': 100, 'fromY': 100, 'toX': 200, 'toY': 200, 'element', element&#125;); mobile: selectPickerWheelValue选择下一个或上一个picker wheel的值。 如果这些值是动态的，那么这个方法是能起作用的。XCTest有一个BUG就是你并不能知道要选择哪一个或者当前的选择区域是否生效。 【支持参数】 element: PickerWheel的内部元素id（作为十六进制哈希字符串）执行值选择。元素必须是XCUIElementTypePickerWheel类型。强制参数 order: next 选择下一个value，previous选择前面一个value。强制参数 offset: 区间值： [0.01, 0.5]。它定义了picker wheel的中心距离应该有多远。 通过将该值乘以实际的picker wheel高度来确定实际距离。太小的偏移值可能不会改变picker wheel的值，而过高的值可能会导致picker wheel同时切换两个或多个值。通常最优值位于范围[0.15,0.3]中。默认为0.2 【用法示例】 1driver.execute_script('mobile: selectPickerWheelValue', &#123;'order': 'next', 'offset': 0.15, 'element': element&#125;); mobile: alert对弹窗执行操作。 【支持参数】 action: 支持以下操作: accept, dismiss and getButtons。强制参数 buttonLabel: 点击已有警报按钮的标签文本。这是一个可选参数，只能与accept和dismiss 操作相结合才有效。 【用法示例】 1driver.execute_script('mobile: alert', &#123;'action': 'accept', 'buttonLabel': 'My Cool Alert Button'&#125;);]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Appium</tag>
        <tag>Python</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在MacOS上搭建Appium的iOS测试环境]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%9C%A8MacOS%E4%B8%8A%E6%90%AD%E5%BB%BAAppium%E7%9A%84iOS%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[本文档基于Xcode8.3.3，appium-desktop-v1.1.1，appium-v1.6.5 准备环境和文件 Mac OS 10.12 iOS 10 Apple ID，没有的可以访问创建您的Apple ID注册 Xcode 8，可从Apple开发者中心下载 xip 安装文件，或者直接从 App Store 下载安装 Node.js，选择 LTS 的 Macintosh Installer 版本 下载页面 appium desktop，Appium 的桌面版，选择 Latest release 的 dmg 文件 下载页面 安装 Appium P.S. 以下安装如果报错没有权限时，以修改目录权限的方式解决，不要使用 sudo 或切换到 root 进行安装，以免后续每次运行都需要修改相关权限 1sudo chmod -R 777 路径 双击 Xcode 安装文件解压，将解压后的文件拉到应用程序中，打开 Xcode 同意 lisence 安装 Xcode Command Line Tools 1xcode-select --install 安装 homebrew，这是用于安装后续工具的包管理器 1/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" 安装 libimobiledevice，这是用于连接 iOS 设备的开源工具，类似于 Android 的 ADB 1brew install libimobiledevice --HEAD 安装 carthage，WebDriverAgent 使用的依赖管理工具 1brew install carthage 双击打开 Node.js 的 pkg 文件，根据提示安装即可，用于安装后续工具 使用淘宝 npm 源安装 cnpm，因为 npm 安装的时候很慢而且经常失败，后面使用 cnpm 代替 npm 1npm install -g cnpm --registry=https://registry.npm.taobao.org 安装 ios-deploy，这是支持使用命令行管理 iOS 设备 app 的工具 1cnpm install -g ios-deploy 双击打开 appium desktop 的 dmg 文件，在打开的窗口中将左边的 Appium 图标拖至右边的 Applications (应用程序) 图标即可；如果想要安装命令行版本，则执行以下命令安装，两个版本可以共存 1cnpm install -g appium 验证安装 安装 appium doctor 1cnpm install -g appium-doctor 运行 appium doctor，检查 appium 的 iOS 环境是否安装完毕 1appium-doctor --ios 常用命令 idevice_id 获取已连接的 iOS 设备的 udid 1idevice_id -l idevicename 获取已连接的 iOS 设备的设备名称 12idevicenameidevicename -u [udid] ideviceinfo 获取 iOS 设备信息 123ideviceinfoideviceinfo -u [udid]ideviceinfo -u [udid] -k [key name] ios-deploy 管理 iOS 设备的 app 12ios-deploy -B # 获取iOS设备上所有app的bundleIDios-deploy -b [ipa文件路径] # 将指定的ipa安装到iOS设备上 在 iOS 设备上安装 WebDriverAgent 安装 WebDriverAgent 依赖，命令行版本可能会提示 Error: Cannot find module &#39;eslint-config-appium&#39;，不会影响正常功能 1234567# Appium 桌面版本cd /Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgentsh ./Scripts/bootstrap.sh# Appium 命令行版本cd /usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgentsh ./Scripts/bootstrap.sh 使用 Xcode 打开 WebDriverAgent 项目：点击 Finder→前往→前往文件夹…，输入以下路径，点击前往，双击文件夹下的 WebDriverAgent.xcodeproj 打开项目 12345# Appium 桌面版本/Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent# Appium 命令行版本/usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgent 在 Xcode 中添加开发者账号：点击上方菜单栏的 Xcode→Preferences→Accounts，点击左下角的 ＋ 按钮，选择 add Apple ID，添加自己的 Apple ID 作为开发者账号 1*免费开发者账号的Provisioning Profile只有7天有效期，7天之后需要使用Xcode将app重新安装一次 编译 WebDriverAgentLib： 勾选 Automatically manage signing，设置 Signning 的 Team 为上一步添加的个人开发者账号，点击右上角的编译按钮，编译成功上方会提示 Build WebDriverAgentLib: Succeeded 编译 WebDriverAgentRunner 修改 Bundle Identifier 为 com.XXXXXX.WebDriverAgentRunner，必须是没有人用过的 勾选Automatically manage signing，设置 Signning 的Team为上一步添加的个人开发者账号，点击右上角的编译按钮，编译成功上方会提示 Build WebDriverAgentRunner: Succeeded Bundle Identifier 是 iOS 应用的唯一标识，如果 Bundle Identifier 已有人使用，会导致无法生成 app 的 Provisioning Profile，如下所示 将 WebDriverAgentRunner 安装到 iOS 设备 以下步骤在使用 Appium 连接 iOS 设备时会自动执行 有两种方式将 WebDriverAgentRunner 安装到 iOS 设备 在 Xcode 中，将 Target 切换为 WebDriverAgentRunner，目标设备选择已连接的 iOS 设备，点击菜单栏的 Product→Test 执行以下命令将 WebDriverAgentRunner 安装到 iOS 设备 1234567# Appium 桌面版本cd /Applications/Appium.app/Contents/Resources/app/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgentxcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination 'id=iOS设备的udid' test# Appium 命令行版本cd /usr/local/lib/node_modules/appium/node_modules/appium-xcuitest-driver/WebDriverAgentxcodebuild -project WebDriverAgent.xcodeproj -scheme WebDriverAgentRunner -destination 'id=iOS设备udid' test 上一步操作后会提示 Test Failed，可以看到 iOS 设备上多了一个叫 WebDriverAgentRunner 的 app，在 iOS 设备上点击 WebDriverAgentRunner 图标启动时会有弹窗提示 不受信任的开发者 在 iOS 设备上，进入 设置→通用→设备管理 ，选择自己的 Apple ID 账号，点击信任 Apple ID 重复第 1 步的操作，可以看到 WebDriverAgentRunner 自动启动，此时提示如下 执行以下命令，将 iOS 设备上 WebDriverAgentRunner 监听的 8100 端口映射到 macOS 本地的 8100 端口 1iproxy 8100 8100 iOS设备udid 调用 WebDriverAgent 接口 打开浏览器，访问http://localhost:8100，可以看到 json 格式的返回信息 访问http://localhost:8100/status，可以查看 WebDriverAgentRunner 的状态 或者在终端中输入以下指令调用 WebDriverAgent 的接口获取对应信息 1curl -X POST $JSON_HEADER -d "&#123;\"using\":\"link text\",\"value\":\"name=测试环境\"&#125;" http://localhost:8100/session/7CD2D40C-8FCB-4306-B5C2-AD68463573BF/elements 更多 url 查询可见WebDriverAgent的github wiki，Appium 对 WebDriverAgent 的接口进行了封装，所以后续不会直接使用到这些接口 使用 appium desktop 连接 iOS模拟器 执行以下命令查看可用的 iOS 模拟器 1xcrun simctl list devices 运行 Appium，点击 Start Server 打开 appium server 控制台输出窗口，点击 Start New Session 打开创建新会话窗口，设置 Desired Capabilities；下图的 Desired Capabilities 意思是：测试的设备是系统为 iOS、系统版本为 10.3、设备名为 iPhone SE 的模拟器，测试的 app 为系统自带的 Safari 浏览器 点击右下角的 Start Session，此时 appium 会启动模拟器，在模拟器上启动 Safari 浏览器，并弹出 appium inspector 窗口 设备 运行 Appium，点击 Start Server 打开 appium server 控制台输出窗口，点击 Start New Session 打开创建新会话窗口，设置 Desired Capabilities；下图的 Desired Capabilities 意思是：测试的设备是系统为 iOS、系统版本为 10.1.1、设备名为 iPhone6、udid 为 966498ff426206145c93…… 的设备，测试的 app 为系统自带的 Safari 浏览器 点击右下角的 Start Session，此时 appium 会启动 iOS 设备上的 Safari 浏览器，并弹出 appium inspector 窗口 iOS 设备的 web 测试环境 安装 ios-webkit-debug-proxy 1brew install ios-webkit-debug-proxy 在 iOS 设备上，进入 设置→Safari→高级，打开 web 检查器 在 iOS 设备上启动 Safari，访问任意网址 执行以下命令，在指定的设备上启动 IWDP 1ios_webkit_debug_proxy -c 设备udid:端口 用浏览器访问 ip地址:端口 ，可以看到 iOS 设备上的 Safari 打开的页面，说明可以在该 iOS 设备上进行 web 自动化测试 ip地址：macOS 的 ip 地址，如果浏览器在 macOS 上则用 localhost 访问即可 端口：第 4 步执行命令时指定的端口 在 iOS 设备上进行 web 自动化的时候，可以使用桌面浏览器的调试工具提高效率，有如下两种方式 在 macOS 上打开 Safari 浏览器，点击上方菜单栏的 开发→[设备名称]→[访问的网址]，打开 Safari 的调试工具 使用 Chrome 浏览器访问以下网址来调试对应的 Safari 标签页 1chrome-devtools://devtools/bundled/inspector.html?ws=[ip地址]:[端口]/devtools/page/[页面序号] ip地址：macOS 的 ip 地址 端口：第 4 步执行命令时指定的端口 页面序号：第 5 步列出的页面前面的序号]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Appium</tag>
        <tag>iOS</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appium简介]]></title>
    <url>%2F2017%2F08%2F26%2FAppium%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[Appium 简介 Appium is an open-source tool for automating native, mobile web, and hybrid applications on iOS mobile, Android mobile, and Windows desktop platforms. Native apps are those written using the iOS, Android, or Windows SDKs. Mobile web appsare web apps accessed using a mobile browser (Appium supports Safari on iOS and Chrome or the built-in ‘Browser’ app on Android). Hybrid apps have a wrapper around a “webview” – a native control that enables interaction with web content. Projects like Phonegap, make it easy to build apps using web technologies that are then bundled into a native wrapper, creating a hybrid app. Importantly, Appium is “cross-platform”: it allows you to write tests against multiple platforms (iOS, Android, Windows), using the same API. This enables code reuse between iOS, Android, and Windows testsuites. 开源的自动化测试工具 支持原生、移动 web 和混合应用 跨平台，对 iOS、Android、Windows 进行自动化测试时使用相同的 API Appium 的理念 Appium was designed to meet mobile automation needs according to a philosophy outlined by the following four tenets: You shouldn’t have to recompile your app or modify it in any way in order to automate it. You shouldn’t be locked into a specific language or framework to write and run your tests. A mobile automation framework shouldn’t reinvent the wheel when it comes to automation APIs. A mobile automation framework should be open source, in spirit and practice as well as in name! 不需要为了自动化而重新编译或者修改应用 不局限于某种语言或者框架来编写和运行测试脚本 一个移动端自动化框架不应该在自动化接口上重复造轮子（移动自动化的接口应该统一） 必须开源 Appium 的设计为了实现上述4条理念，appium 设计如下 在 appium 引擎下使用操作系统提供的自动化框架 iOS 9.3 及以上: 苹果的 XCUITest iOS 9.3 及以下: 苹果的 UIAutomation Android 4.2+: 谷歌的 UiAutomator Android 2.3+: 谷歌的 Instrumentation （Selendroid 提供 Instrumentation 的支持） Windows: 微软的 WinAppDriver 将上述自动化框架封装成一套 API：WebDriver API， WebDriver 指定了客户端-服务端协议（JSON Wire Protocol）。基于客户端-服务端的架构，我们可以使用任何编程语言来编写客户端，向服务端发送恰当的 HTTP 请求，以 iOS 为例，appium 的架构如下图所示。目前 appium 已经实现了大多数流行语言版本的客户端，这意味着我们可以使用任何测试套件或者测试框架 扩充 WebDriver 的协议，实现了 Mobile JSON Wire Protocol，在 JSON Wire Protocol 的基础上添加移动自动化相关的 API 方法 Appium 的 github Appium 的概念C/S 架构Appium 的核心是一个 web 服务器，它提供了一套 REST 的接口。它收到客户端的连接，监听到命令，接着在移动设备上执行这些命令，然后将执行结果放在 HTTP 响应中返还给客户端。事实上，这种客户端/服务端的架构给予了许多的可能性：比如我们可以使用任何实现了该客户端的语言来写我们的测试代码。比如我们可以把服务端放在不同的机器上。比如我们可以只写测试代码，然后使用像 Sauce Labs 这样的云服务来解释命令。 Appium 服务端Appium server 是用 Node.js 写的。我们可以用源码编译或者从 NPM 直接安装。 Appium 客户端Appium 客户端有很多语言库 Java, Ruby, Python, PHP, JavaScript 和 C#，这些库都实现了 Appium 对 WebDriver 协议的扩展。当使用 Appium 的时候，只需使用这些库代替常规的 WebDriver 库就可以了。 以下是目前的客户端类库列表以及对应的项目开源地址，可以访问 网址查看所有的库的列表。 语言/框架 Github版本库以及安装指南 Ruby https://github.com/appium/ruby_lib Python https://github.com/appium/python-client Java https://github.com/appium/java-client JavaScript (Node.js) https://github.com/admc/wd Objective C https://github.com/appium/selenium-objective-c PHP https://github.com/appium/php-client C# (.NET) https://github.com/appium/appium-dotnet-driver RobotFramework https://github.com/jollychang/robotframework-appiumlibrary Session（会话）自动化始终围绕一个 session 进行，客户端初始化一个 seesion（会话）来与服务端交互，发送一个 POST 请求给服务端，请求中包含一个 JSON 对象，被称作“desired capabilities”，服务端会根据 desired capabilities 开启一个自动化的 session，然后返回一个 session ID，客户端使用这个 session ID 发送后续的命令。 Desired Capabilities：创建Session 所需的参数Desired capabilities 是一些键值对 (key-value) 的集合，客户端将这些键值对发给服务端，告诉服务端我们想要怎么测试。比如如下所示的 Desired capabilities，表示测试的设备是系统为 iOS、系统版本为 10.3 、设备名为 iPhone SE 的模拟器，测试 app 的 bundleId 为 com.apple.mobilesafari，也就是系统自带的 safari 浏览器。访问 capabilities文档 查看完整的 capabilities 列表。 123456&#123; "platformName": "iOS", "platformVersion": "10.3", "deviceName": "iPhone SE", "bundleId": "com.apple.mobilesafari"&#125; Appium 服务端的桌面版：appium-desktop.dmg, appium-desktop.exeAppium 提供了 GUI 封装的 Appium 服务端下载，它封装了运行 Appium 服务端的所有依赖，而不需要担心怎样安装 Node.js。其中还包括一个 Inspector 工具，可以帮助你检查应用的界面层级，这样写测试用例时更方便。 WebDriverAgent 介绍 WebDriverAgent is a WebDriver server implementation for iOS that can be used to remote control iOS devices. It allows you to launch &amp; kill applications, tap &amp; scroll views or confirm view presence on a screen. This makes it a perfect tool for application end-to-end testing or general purpose device automation. It works by linking XCTest.framework and calling Apple’s API to execute commands directly on a device. WebDriverAgent is developed and used at Facebook for end-to-end testing and is successfully adopted by Appium. WebDriverAgent 是 Facebook 的一个开源项目，它在 iOS 端实现了一个 WebDriver server，借助这个 server 我们可以远程控制 iOS 设备，可以进行启动和终止 app、点击、滚动屏幕、确认显示内容是否正确等操作。WebDriverAgent 通过链接 XCTest.framework 调用 Apple 的 API 直接在设备上执行命令。]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>Appium</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Windows上使用VMware安装MacOS虚拟机]]></title>
    <url>%2F2017%2F08%2F26%2F%E5%9C%A8Windows%E4%B8%8A%E4%BD%BF%E7%94%A8VMware%E5%AE%89%E8%A3%85MacOS%E8%99%9A%E6%8B%9F%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[准备文件 macOS 操作系统 iso 文件（需要使用 macOS 下载安装文件，使用 工具 转换成 iso） Unlocker 2.0.8 下载地址 VMware Workstation 12，player 或 pro 都可以 安装步骤 安装 VMware 解压下载的 Unlocker，以管理员身份执行文件夹中的 win-install.cmd，解锁创建新虚拟机时的 macOS 选项 打开 VMware→创建新虚拟机→选择稍后安装操作系统→选择对应的操作系统类型和版本→命名虚拟机和设置虚拟机保存位置→设置磁盘大小→自定义硬件，参数设置参考如下： USB 兼容性选择 USB 2.0（设置为 USB 3.0 可能导致无法在虚拟机和宿主机之间顺利切换 USB 设备） cpu 核心越多越好 内存最好 8G 以上 硬盘 40G 以上 CD/DVD 选择 macOS iso 文件 打开虚拟机保存位置，使用文本编辑工具修改文件夹下的 vmx 文件，在末尾添加如下这行配置 1smc.version = &quot;0&quot; 播放虚拟机，选择语言并同意条款，来到“选择安装到的磁盘”页面，此时显示只有挂载的 iso，打开磁盘工具 选择名称为 VMware 开头的磁盘，点击抹掉，按默认参数创建磁盘分区，关闭磁盘工具，选择刚才创建的磁盘，点击继续，等待安装完成 安装 VMware tools]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>VMware</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
</search>
